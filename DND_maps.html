<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8">
<title>D&D Map Maker — 0.7.5</title>
<script src="https://unpkg.com/konva@9.3.1/konva.min.js"></script>
<style>
  :root { --left:200px; --right:320px; }
  html,body { margin:0; height:100%; background:#222; color:#eee; font-family:Arial, sans-serif; }
  .layout { display:flex; height:100vh; }
  .panel { background:#333; padding:10px; box-sizing:border-box; overflow:auto; }
  .left  { width:var(--left); }
  .right { width:var(--right); }
  #container { flex:1; background:#444; cursor:grab; }

  h3 { margin:6px 0; font-size:15px; }
  .asset, .objItem {
    padding:6px; margin-bottom:8px;
    background:#4b4b4b; border:1px solid #555; border-radius:6px; cursor:pointer;
  }
  .asset img.thumb{max-width:100%;height:auto;display:block;margin-top:4px;object-fit:contain;}
  .asset:hover { background:#5f5f5f; }
  .objItem.active { background:#c8b56a; color:#000; }

  button, input[type=file], select {
    width:100%; padding:8px; margin-top:8px;
    border:0; background:#5a5a5a; color:#fff; border-radius:6px; cursor:pointer;
    box-sizing:border-box;
  }
  button:hover, input[type=file]:hover, select:hover { background:#777; }

  .info { font-size:12px; color:#ccc; margin-top:8px; }

  /* персонажи (панель) */
  .charItem {
    background:#3f3f3f; border:1px solid #555;
    padding:8px; margin-bottom:8px; border-radius:6px;
  }
  .charRow { display:flex; flex-wrap:wrap; gap:6px; align-items:center; }
  .charRow img { width:48px; height:48px; border-radius:6px; object-fit:cover; cursor:pointer; border:2px solid #222; }
  .charRow input[type=number], .charRow input[type=text] {
    padding:6px; border-radius:4px; border:0; background:#555; color:#fff;
  }
  .charRow input[type=number] { width:72px; max-width:72px; }
  .charRow input[type=text] { flex:1 1 120px; max-width:150px; }
  .charBtns { display:flex; flex-wrap:wrap; gap:6px; margin-top:8px; }
  .charBtns button { flex:1 1 48%; padding:6px; box-sizing:border-box; }

  /* кубики */
  .diceBtns { display:flex; gap:6px; flex-wrap:wrap; margin-top:6px; }
  .diceBtns button { flex:1 1 48px; padding:6px; }
  #diceResult { margin-top:6px; font-weight:bold; text-align:center; }

  /* small responsive tweak */
  @media (max-width:900px){
    :root { --right:260px; }
  }

  /* token visual tweaks ensure on top */
  canvas { image-rendering: optimizeSpeed; }
</style>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>

</head>
<body>

<div id="authModal" style="position:fixed;inset:0;background:#000c;display:flex;
align-items:center;justify-content:center;z-index:9999;">
  <div style="background:#333;padding:20px;border-radius:8px;max-width:300px;">
    <h3>Вход / Регистрация</h3>
    <input id="email" type="email" placeholder="Email" style="width:100%;margin-top:8px;">
    <input id="pass" type="password" placeholder="Пароль" style="width:100%;margin-top:8px;">
    <button id="loginBtn" style="margin-top:10px;">Войти</button>
    <button id="signupBtn" style="margin-top:6px;">Создать аккаунт</button>
    <div id="authErr" style="color:#f88;margin-top:6px;font-size:13px;"></div>
  </div>
</div>
<!-- === Панель комнат === -->
<div id="roomPanel" style="margin-top:20px;">
  <h3>Комнаты</h3>
  <input id="roomName" type="text" placeholder="Название комнаты">
  <button id="createRoomBtn">Создать комнату</button>
  <div id="roomsList"></div>
</div>
<!-- === /Панель комнат === -->
<div class="layout">

  <!-- Левая панель -->
  <div class="panel left">
    <h3>Ассеты</h3>
    <div id="assetList"></div>
    <input id="fileInput" type="file" accept="image/*">
    <button id="savePngBtn">Сохранить карту (PNG)</button>
    <button id="saveJsonBtn">Сохранить проект (JSON)</button>
    <input id="loadJson" type="file" accept="application/json">
  </div>

  <!-- Центральное поле -->
  <div id="container"></div>

  <!-- Правая панель -->
  <div class="panel right">
    <h3>Объекты</h3>
    <div id="objects"></div>
    <button id="deleteBtn">Удалить выбранный</button>
    <button id="copyBtn">Копировать выбранный</button>
    <button id="mirrorBtn">Отзеркалить по горизонтали</button>
    <button id="layerUpBtn">Вперёд (выше)</button>
    <button id="layerDownBtn">Назад (ниже)</button>

    <h3 style="margin-top:14px;">Фон</h3>
    <input id="bgFile" type="file" accept="image/*">

    <h3 style="margin-top:14px;">Персонажи (токены)</h3>
    <button id="addCharBtn">Добавить персонажа</button>
    <div id="characters"></div>

    <h3 style="margin-top:12px;">Кубики</h3>
    <div class="diceBtns">
      <button onclick="roll(4)">d4</button>
      <button onclick="roll(6)">d6</button>
      <button onclick="roll(8)">d8</button>
      <button onclick="roll(12)">d12</button>
      <button onclick="roll(20)">d20</button>
    </div>
    <div id="diceResult">—</div>

    <div class="info">
      • ЛКМ по пустому — перетаскивание карты<br>
      • Колёсико — масштаб сцены или объекта<br>
      • Клик по токену — выделить персонажа (подсветка рамки)<br>
      • Токены находятся на отдельном слое поверх объектов
    </div>
  </div>

</div>

<!-- скрытые input'ы -->
<input id="charImageInput" type="file" accept="image/*" style="display:none">

<script>

// --- Firebase init ---
const firebaseConfig = {
  apiKey: "AIzaSyBh9hdRHlutkp-KzidGy4HI7C1WefsY9UI",
  authDomain: "dnd-map-80839.firebaseapp.com",
  projectId: "dnd-map-80839",
  storageBucket: "dnd-map-80839.firebasestorage.app",
  messagingSenderId: "19440089702",
  appId: "1:19440089702:web:14beea350316db9b520ba7"
};
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db   = firebase.firestore();
// --- Auth logic ---
const authModal = document.getElementById('authModal');
const emailInp  = document.getElementById('email');
const passInp   = document.getElementById('pass');
const errBox    = document.getElementById('authErr');

document.getElementById('loginBtn').onclick = () => {
  auth.signInWithEmailAndPassword(emailInp.value, passInp.value)
    .catch(e => errBox.textContent = e.message);
};
document.getElementById('signupBtn').onclick = () => {
  auth.createUserWithEmailAndPassword(emailInp.value, passInp.value)
    .catch(e => errBox.textContent = e.message);
};

auth.onAuthStateChanged(user => {
  if (user) {
    authModal.style.display = 'none';        // спрятать модалку
    console.log('Logged in as', user.email); // вы можете показывать имя в UI
  } else {
    authModal.style.display = 'flex';
  }
});
// --- Firestore Rooms helpers ---
function createRoom(name){
  return db.collection('rooms').add({
    name,
    owner: auth.currentUser.uid,
    created: firebase.firestore.FieldValue.serverTimestamp()
  });
}

function listRooms(){
  db.collection('rooms')
    .orderBy('created','desc')
    .onSnapshot(snap=>{
      // здесь вы решаете, как выводить список:
      // например в консоль или в отдельный div
      console.clear();
      snap.forEach(doc=>{
        console.log(doc.id, doc.data());
      });
    });
}
// ----- Работа с комнатами -----
const db = firebase.firestore();
let currentUser = null;

firebase.auth().onAuthStateChanged(user => {
  currentUser = user;
  if (user) loadRooms();
  else document.getElementById('roomsList').innerHTML = '';
});

document.getElementById('createRoomBtn').onclick = async () => {
  const name = document.getElementById('roomName').value.trim();
  if (!name || !currentUser) return;
  await db.collection('rooms').add({
    name,
    owner: currentUser.uid,
    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
    players: [currentUser.uid]
  });
  document.getElementById('roomName').value = '';
};

function loadRooms() {
  db.collection('rooms').orderBy('createdAt','desc')
    .onSnapshot(snapshot => {
      const list = document.getElementById('roomsList');
      list.innerHTML = '';
      snapshot.forEach(doc => {
        const room = doc.data();
        const div = document.createElement('div');
        div.className = 'roomItem';
        div.textContent = room.name + (room.owner === currentUser.uid ? ' (моя)' : '');
        div.onclick = () => joinRoom(doc.id, room);
        list.appendChild(div);
      });
    });
}

async function joinRoom(roomId, room) {
  if (!currentUser) return;
  await db.collection('rooms').doc(roomId).update({
    players: firebase.firestore.FieldValue.arrayUnion(currentUser.uid)
  });
  alert('Вы вошли в комнату: ' + room.name);

/* ---------- Ассеты ---------- */
const assets = [
  {name:'Деревянный дом', url:'assets/wood_house.png'},
  {name:'Каменный дом',   url:'assets/stone_house.png'},
  {name:'Замок',          url:'assets/castle.png'},
  {name:'Таверна',        url:'assets/tavern.png'},
  {name:'Гильдия',        url:'assets/guild.png'},
  {name:'Лес',            url:'assets/forest.png'},
  {name:'Поляна',         url:'assets/clearing.png'},
  {name:'Вход в подземелье', url:'assets/dungeon_entrance.png'},
  {name:'Комната подземелья', url:'assets/dungeon_room.png'},
  {name:'Сундук',            url:'assets/dungeon_chest.png'},
  {name:'Факел',             url:'assets/dungeon_torch.png'},
  {name:'Руины',             url:'assets/dungeon_rocks.png'},
  {name:'Каменная тропинка',  url:'assets/stone_path.png'},
  {name:'Земляная тропинка',  url:'assets/earth_path.png'}
];

/* ---------- Stage и слои ---------- */
const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth - (parseInt(getComputedStyle(document.documentElement).getPropertyValue('--left')) + parseInt(getComputedStyle(document.documentElement).getPropertyValue('--right'))),
  height: window.innerHeight
});
const backgroundLayer = new Konva.Layer();
const gridLayer = new Konva.Layer();
const objectLayer = new Konva.Layer();
const tokenLayer = new Konva.Layer(); // tokens above objects
stage.add(backgroundLayer);
stage.add(gridLayer);
stage.add(objectLayer);
stage.add(tokenLayer);

/* Сетка */
function drawGrid(cell=48){
  gridLayer.destroyChildren();
  const w = stage.width(), h = stage.height();
  for(let i=0;i<=Math.ceil(w/cell);i++){
    gridLayer.add(new Konva.Line({ points:[i*cell,0,i*cell,h], stroke:'rgba(255,255,255,0.12)', strokeWidth:1 }));
  }
  for(let j=0;j<=Math.ceil(h/cell);j++){
    gridLayer.add(new Konva.Line({ points:[0,j*cell,w,j*cell], stroke:'rgba(255,255,255,0.12)', strokeWidth:1 }));
  }
  gridLayer.batchDraw();
}
drawGrid();

/* UI ассетов */
const assetList = document.getElementById('assetList');
assets.forEach(a=>{
  const d = document.createElement('div');
  d.className = 'asset';
  d.innerHTML = `<strong>${a.name}</strong><img class="thumb" src="${a.url}" alt="${a.name}">`;
  d.onclick = ()=> addAsset(a.url, a.name);
  assetList.appendChild(d);
});

/* ---------- Объекты (слой объектов) ---------- */
let objectsData = []; // {id,name,url,node}
let selectedId = null;
let idCounter = 1;

const transformer = new Konva.Transformer({
  rotateEnabled: true,
  enabledAnchors: ['top-left','top-right','bottom-left','bottom-right','middle-left','middle-right','top-center','bottom-center'],
  boundBoxFunc:(oldBox,newBox)=> (newBox.width<8 || newBox.height<8) ? oldBox : newBox
});
objectLayer.add(transformer);

function addAsset(url,name,x=null,y=null,extra={}){
  Konva.Image.fromURL(url, img=>{
    const w = img.width() || 64, h = img.height() || 64;
    const id = 'obj_' + Date.now() + '_' + (idCounter++);
    img.setAttrs({
      x: x ?? stage.width()/2 - w/4,
      y: y ?? stage.height()/2 - h/4,
      width: extra.width ?? Math.round(w/2),
      height: extra.height ?? Math.round(h/2),
      draggable: true,
      id,
      ...extra
    });
    img.on('click', e => { e.cancelBubble = true; toggleSelect(id); });
    img.on('dragend transformend', refreshObjectList);
    objectLayer.add(img);
    objectsData.push({id, name, url, node: img});
    selectObject(id);
    refreshObjectList();
  });
}

const objectsDiv = document.getElementById('objects');
function refreshObjectList(){
  objectsDiv.innerHTML = '';
  objectsData.forEach(o=>{
    const div = document.createElement('div');
    div.className = 'objItem' + (o.id === selectedId ? ' active' : '');
    div.textContent = o.name;
    div.onclick = ()=> toggleSelect(o.id);
    objectsDiv.appendChild(div);
  });
}
function selectObject(id){
  selectedId = id;
  const entry = objectsData.find(o=>o.id === id);
  if(entry) transformer.nodes([entry.node]);
  objectLayer.batchDraw();
  refreshObjectList();
}
function toggleSelect(id){ selectedId === id ? deselect() : selectObject(id); }
function deselect(){ selectedId = null; transformer.nodes([]); objectLayer.batchDraw(); refreshObjectList(); }
stage.on('mousedown', e => { if(e.target===stage || e.target === backgroundLayer || e.target === gridLayer) deselect(); });

/* Удаление / копирование / зеркало / слои */
document.getElementById('deleteBtn').onclick = ()=>{ if(!selectedId) return; const i = objectsData.findIndex(o=>o.id===selectedId); if(i>=0){ objectsData[i].node.destroy(); objectsData.splice(i,1); deselect(); refreshObjectList(); }};
document.getElementById('copyBtn').onclick = ()=>{ if(!selectedId) return; const obj = objectsData.find(o=>o.id===selectedId); if(!obj) return; const n = obj.node; const pos = stage.getPointerPosition() || {x:n.x()+20,y:n.y()+20}; addAsset(obj.url, obj.name+' (копия)', pos.x, pos.y, { width: n.width(), height: n.height(), scaleX: n.scaleX(), scaleY: n.scaleY(), rotation: n.rotation() });};
document.getElementById('mirrorBtn').onclick = ()=>{ if(!selectedId) return; const obj = objectsData.find(o=>o.id===selectedId); obj.node.scaleX(obj.node.scaleX() * -1); objectLayer.batchDraw(); };
document.getElementById('layerUpBtn').onclick = ()=>{ if(!selectedId) return; objectsData.find(o=>o.id===selectedId).node.moveUp(); objectLayer.batchDraw(); };
document.getElementById('layerDownBtn').onclick = ()=>{ if(!selectedId) return; objectsData.find(o=>o.id===selectedId).node.moveDown(); objectLayer.batchDraw(); };

/* Масштаб сцены/объекта */
stage.on('wheel', e=>{
  e.evt.preventDefault();
  const ptr = stage.getPointerPosition();
  if(selectedId){
    const t = objectsData.find(o=>o.id===selectedId);
    if(t && stage.getIntersection(ptr) === t.node){
      const k = e.evt.deltaY > 0 ? 0.9 : 1.1;
      const s = t.node.scaleX() * k;
      if(s > 0.1 && s < 10){ t.node.scale({x:s,y:s}); objectLayer.batchDraw(); }
      return;
    }
  }
  const scaleBy = 1.1;
  const old = stage.scaleX();
  const mp = { x: (ptr.x - stage.x()) / old, y: (ptr.y - stage.y()) / old };
  const dir = e.evt.deltaY > 0 ? -1 : 1;
  const newS = dir > 0 ? old * scaleBy : old / scaleBy;
  stage.scale({x:newS,y:newS});
  stage.position({x: ptr.x - mp.x*newS, y: ptr.y - mp.y*newS});
  stage.batchDraw();
});

/* Панорамирование сцены */
let isPanning=false, lastPos=null;
const cont = document.getElementById('container');
cont.addEventListener('mousedown', e=>{
  // start panning only when clicking empty space (not on object/token)
  const pointer = stage.getPointerPosition();
  const target = stage.getIntersection(pointer);
  if(!target){
    isPanning=true; cont.style.cursor='grabbing'; lastPos={x:e.clientX,y:e.clientY};
  }
});
cont.addEventListener('mousemove', e=>{
  if(!isPanning) return;
  const dx=e.clientX-lastPos.x, dy=e.clientY-lastPos.y;
  lastPos={x:e.clientX,y:e.clientY};
  stage.position({x: stage.x()+dx, y: stage.y()+dy});
  stage.batchDraw();
});
cont.addEventListener('mouseup', ()=>{ isPanning=false; cont.style.cursor='grab'; });
cont.addEventListener('mouseleave', ()=>{ isPanning=false; cont.style.cursor='grab'; });

/* Загрузка своих ассетов */
document.getElementById('fileInput').onchange = e=>{
  const f = e.target.files[0]; if(!f) return;
  const r = new FileReader();
  r.onload = ev => addAsset(ev.target.result, f.name);
  r.readAsDataURL(f);
  e.target.value = '';
};

/* Сохранение PNG */
document.getElementById('savePngBtn').onclick = ()=>{
  const uri = stage.toDataURL({ pixelRatio:2 });
  const a = document.createElement('a'); a.href = uri; a.download = 'dnd_map.png'; a.click();
};

/* ---------- Персонажи / токены ---------- */
let characters = []; // each: { name, hp, maxHp, cd, speed, url, x, y, size, _group,... }
let selectedCharacterIndex = null;
const charDiv = document.getElementById('characters');
const charImageInput = document.getElementById('charImageInput');

function createTokenNode(ch, i){
  if(ch._group && ch._group.destroy) ch._group.destroy();

  const size = ch.size || 64;
  const group = new Konva.Group({
    x: (ch.x !== undefined ? ch.x : stage.width()/2 - size/2),
    y: (ch.y !== undefined ? ch.y : stage.height()/2 - size/2),
    draggable: true,
    id: 'char_' + i
  });

  // border rectangle (highlight)
  const border = new Konva.Rect({
    x: 0, y: 0, width: size, height: size, stroke: '#fff', strokeWidth: 2, cornerRadius: 8
  });

  // avatar image area (inset)
  const avatar = new Konva.Image({ x:4, y:4, width: size-8, height: size-8, listening: false });

  // HP text under avatar
  const hpText = new Konva.Text({
    x:0, y:size+4, width:size, align:'center',
    text:`HP: ${ch.hp}`, fill:'#e33', fontSize:14, fontStyle:'bold', listening:false
  });

  group.add(border, avatar, hpText);
  tokenLayer.add(group);
  tokenLayer.moveToTop();
  tokenLayer.batchDraw();

  // load avatar image if exists
  if(ch.url){
    const img = new Image();
    img.onload = ()=> { avatar.image(img); tokenLayer.batchDraw(); };
    img.src = ch.url;
  } else {
    // placeholder
    const canvas = document.createElement('canvas'); canvas.width = size-8; canvas.height = size-8;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#666'; ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#aaa'; ctx.textAlign='center'; ctx.font='12px sans-serif';
    ctx.fillText('avatar', canvas.width/2, canvas.height/2);
    const img = new Image();
    img.onload = ()=> { avatar.image(img); tokenLayer.batchDraw(); };
    img.src = canvas.toDataURL();
  }

  // events
  group.on('dragend', ()=>{
    ch.x = Math.round(group.x());
    ch.y = Math.round(group.y());
  });

  group.on('click', e=>{
    e.cancelBubble = true;
    selectedCharacterIndex = i;
    updateCharacterHighlight();
    refreshCharacters();
  });

  // store refs
  ch._group = group;
  ch._avatar = avatar;
  ch._border = border;
  ch._hpText = hpText;
  ch._size = size;
  updateCharacterHighlight();
}

function updateCharacterNode(i){
  const ch = characters[i];
  if(!ch) return;
  const size = ch._size || ch.size || 64;
  const maxHp = ch.maxHp || ch.hp || 1;
  if(ch._hpText) ch._hpText.text(`HP: ${ch.hp}`);
  tokenLayer.batchDraw();
  refreshCharacters(); // ensure UI sync
}

function updateCharacterHighlight(){
  characters.forEach((ch, idx)=>{
    if(ch._border){
      ch._border.stroke(idx === selectedCharacterIndex ? '#7df' : '#fff');
      ch._border.strokeWidth(idx === selectedCharacterIndex ? 3 : 2);
    }
  });
  tokenLayer.batchDraw();
}

function refreshCharacters(){
  charDiv.innerHTML = '';
  characters.forEach((ch, i)=>{
    const el = document.createElement('div');
    el.className = 'charItem';
    el.innerHTML = `
      <div class="charRow">
        <img id="img_${i}" src="${ch.url||''}" alt="${escapeHtml(ch.name)}">
        <input id="name_${i}" type="text" value="${escapeHtml(ch.name)}">
        <input id="hp_${i}" type="number" value="${ch.hp}" title="HP">
        <input id="cd_${i}" type="number" value="${ch.cd}" title="КД">
        <input id="sp_${i}" type="number" value="${ch.speed}" title="Скорость">
      </div>
      <div class="charBtns">
        <button id="btnImg_${i}">Сменить изображение</button>
        <button id="btnCenter_${i}">Центр на экране</button>
        <button id="btnDamage_${i}">− Урон</button>
        <button id="btnHeal_${i}">+ Лечение</button>
        <button id="btnRemove_${i}">Удалить</button>
      </div>
    `;
    charDiv.appendChild(el);

    // wire inputs
    el.querySelector(`#name_${i}`).addEventListener('input', e=>{ ch.name = e.target.value; });
    el.querySelector(`#hp_${i}`).addEventListener('input', e=>{
      ch.hp = Number(e.target.value) || 0;
      if(!ch.maxHp) ch.maxHp = ch.hp;
      updateCharacterNode(i);
    });
    el.querySelector(`#cd_${i}`).addEventListener('input', e=>{ ch.cd = Number(e.target.value)||0; });
    el.querySelector(`#sp_${i}`).addEventListener('input', e=>{ ch.speed = Number(e.target.value)||0; });

    // change image
    el.querySelector(`#btnImg_${i}`).addEventListener('click', ()=>{
      charImageInput.dataset.index = i;
      charImageInput.click();
    });

    // center view on token
    el.querySelector(`#btnCenter_${i}`).addEventListener('click', ()=>{
      const g = ch._group;
      if(!g) return;
      const gs = stage.scaleX();
      stage.position({ x: stage.width()/2 - g.x()*gs, y: stage.height()/2 - g.y()*gs });
      stage.batchDraw();
    });

    el.querySelector(`#btnDamage_${i}`).addEventListener('click', ()=> damageCharPrompt(i));
    el.querySelector(`#btnHeal_${i}`).addEventListener('click', ()=> healCharPrompt(i));
    el.querySelector(`#btnRemove_${i}`).addEventListener('click', ()=>{
      if(!confirm('Удалить персонажа?')) return;
      if(ch._group) ch._group.destroy();
      characters.splice(i,1);
      // rebuild nodes (indexes changed)
      characters.forEach((c, idx)=>{ if(c._group) c._group.destroy(); });
      characters.forEach((c, idx)=> createTokenNode(c, idx));
      selectedCharacterIndex = null;
      refreshCharacters();
    });

    // clicking avatar in panel should also open change image
    el.querySelector(`#img_${i}`).addEventListener('click', ()=>{ charImageInput.dataset.index = i; charImageInput.click(); });

  });
}

// add new character (prompts for name, creates token, opens file dialog)
document.getElementById('addCharBtn').addEventListener('click', ()=>{
  const name = prompt('Имя персонажа:', 'Герой');
  if(!name) return;
  const ch = { name, hp:10, maxHp:10, cd:0, speed:30, url:null, x: undefined, y: undefined, size: 64 };
  characters.push(ch);
  const idx = characters.length - 1;
  createTokenNode(ch, idx);
  refreshCharacters();
  // open file dialog to upload avatar
  charImageInput.dataset.index = idx;
  charImageInput.click();
});

// handle image selection for a character (updates existing token, no duplication)
charImageInput.addEventListener('change', e=>{
  const f = e.target.files[0];
  const idx = Number(charImageInput.dataset.index);
  if(!f || !Number.isFinite(idx) || !characters[idx]) { charImageInput.value=''; return; }
  const reader = new FileReader();
  reader.onload = ev => {
    const dataUrl = ev.target.result;
    const ch = characters[idx];
    ch.url = dataUrl;
    // update avatar image node if exists
    const img = new Image();
    img.onload = ()=> {
      if(ch._avatar){ ch._avatar.image(img); tokenLayer.batchDraw(); }
      else createTokenNode(ch, idx);
      refreshCharacters();
    };
    img.src = dataUrl;
    charImageInput.value = '';
  };
  reader.readAsDataURL(f);
});

// hp adjust prompts
function damageCharPrompt(i){
  const val = Number(prompt('Нанести урон (HP):', '1')) || 0;
  characters[i].hp = Math.max(0, (characters[i].hp||0) - val);
  updateCharacterNode(i);
}
function healCharPrompt(i){
  const val = Number(prompt('Восстановить HP:', '1')) || 0;
  characters[i].hp = (characters[i].hp||0) + val;
  if(!characters[i].maxHp) characters[i].maxHp = characters[i].hp;
  updateCharacterNode(i);
}

/* ---------- Export / Import (JSON) ---------- */
function exportProject(){
  return {
    stage: { x: stage.x(), y: stage.y(), scale: stage.scaleX() },
    objects: objectsData.map(o=>({
      name: o.name, url: o.url,
      x: o.node.x(), y: o.node.y(),
      width: o.node.width(), height: o.node.height(),
      scaleX: o.node.scaleX(), scaleY: o.node.scaleY(),
      rotation: o.node.rotation(), zIndex: o.node.zIndex()
    })),
    characters: characters.map(ch=>({
      name: ch.name, hp: ch.hp, maxHp: ch.maxHp, cd: ch.cd, speed: ch.speed,
      url: ch.url, x: ch.x, y: ch.y, size: ch.size
    }))
  };
}

document.getElementById('saveJsonBtn').onclick = ()=>{
  const blob = new Blob([JSON.stringify(exportProject())], {type:'application/json'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'dnd_project.json'; a.click();
};

document.getElementById('loadJson').onchange = e=>{
  const f = e.target.files[0]; if(!f) return;
  const r = new FileReader();
  r.onload = ev=>{
    try{
      const data = JSON.parse(ev.target.result);
      // clear objects
      objectsData.forEach(o=>o.node.destroy());
      objectsData = [];
      deselect();
      (data.objects||[]).sort((a,b)=>a.zIndex-b.zIndex).forEach(o=>{
        addAsset(o.url, o.name, o.x, o.y, {
          width: o.width, height: o.height, scaleX: o.scaleX, scaleY: o.scaleY, rotation: o.rotation
        });
      });
      // restore stage transform
      if(data.stage){
        stage.position({x: data.stage.x||0, y: data.stage.y||0});
        const s = data.stage.scale || 1; stage.scale({x:s,y:s});
      }
      // restore characters
      characters.forEach(ch=>{ if(ch._group) ch._group.destroy(); });
      characters = [];
      (data.characters||[]).forEach((chData)=>{
        const ch = {
          name: chData.name || 'Char', hp: chData.hp ?? 10, maxHp: chData.maxHp ?? (chData.hp ?? 10),
          cd: chData.cd ?? 0, speed: chData.speed ?? 30,
          url: chData.url || null, x: chData.x, y: chData.y, size: chData.size || 64
        };
        characters.push(ch);
      });
      characters.forEach((ch, idx)=> createTokenNode(ch, idx));
      refreshCharacters();
      stage.batchDraw();
    }catch(err){
      alert('Ошибка при загрузке JSON: '+err.message);
    }
  };
  r.readAsText(f);
  e.target.value='';
};

/* ---------- Background image ---------- */
document.getElementById('bgFile').onchange = e=>{
  const f = e.target.files[0]; if(!f) return;
  const r = new FileReader();
  r.onload = ev=>{
    backgroundLayer.destroyChildren();
    Konva.Image.fromURL(ev.target.result, img=>{
      img.setAttrs({ x:0, y:0, width: stage.width(), height: stage.height(), listening:false });
      backgroundLayer.add(img);
      backgroundLayer.batchDraw();
      gridLayer.moveToTop();
    });
  };
  r.readAsDataURL(f);
  e.target.value='';
};

/* ---------- Dice (кубики) ---------- */
function roll(sides){
  const val = 1 + Math.floor(Math.random()*sides);
  document.getElementById('diceResult').textContent = `Результат: d${sides} → ${val}`;
}

/* ---------- Resize ---------- */
window.addEventListener('resize', ()=>{ 
  stage.width(window.innerWidth - (parseInt(getComputedStyle(document.documentElement).getPropertyValue('--left')) + parseInt(getComputedStyle(document.documentElement).getPropertyValue('--right'))));
  stage.height(window.innerHeight);
  backgroundLayer.getChildren().forEach(img=>{ img.width(stage.width()); img.height(stage.height()); });
  backgroundLayer.batchDraw();
  drawGrid();
});

/* ---------- Utilities ---------- */
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

/* ensure clicking empty area deselects both objects and characters */
stage.on('mousedown', e=>{
  if (e.target === stage || e.target === backgroundLayer || e.target === gridLayer) {
    deselect();
    selectedCharacterIndex = null;
    updateCharacterHighlight();
    refreshCharacters();
  }
});
</script>
</body>
</html>


